{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/object-book1/","result":{"data":{"site":{"siteMetadata":{"sponsor":{"buyMeACoffeeId":"Tob0c39"}}},"markdownRemark":{"html":"<p>개인적으로 개발을 하면서 꼭 필요한 것 중의 <strong>하나가 개발에 대한 경험</strong>이고, 또 다른 하나가 그 경험을 통한 <strong>사고의 정리와 확장</strong>에 있다. 개발경력은 단지 숫자에 불과할 뿐이다. 그 시간동안 얼마나 <strong>다양한 경험과 깊은 고민을 했는지</strong>가 현재 자신의 개발 역량을 만들어 간다.</p>\n<p>하지만, 어디 개발 뿐이겠는가? ㅋㅋ</p>\n<p>물론, 천재적인(?) 감각과 통찰력으로 책 만보고도 잘하는 사람도 드물게 있긴 하다. 하지만 나 같은 범인들은 <code>당하지 않고는 느끼지 못하고, 고민하지 않으면 통찰력을 얻을 수 없다.</code></p>\n<p>그래서 마침 좋은 책도 나오고 해서 FE개발 좀 했다는 노친네(?) 분들과 오브젝트 책으로 생각을 정리할 목적으로 스터디를 시작했다.</p>\n<p>스터디라고해서 뭐 거창한 것은 아니고 그냥 책을 읽어와서 이런 저런 잡담을 주기적으로 하는 시간을 갖기로 했다.</p>\n<p>오늘은 그 첫번째로 이 책의 1~2장에 대한 내용을 토대로 이야기했던 내용. 그리고 내 생각들의 정리를 위한 기록들이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 400px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 125.15337423312883%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAZABQDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAMBBAUCBv/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHYivlS+kFCJ4vyKhhR/8QAGxAAAwACAwAAAAAAAAAAAAAAAQIDABIQEzH/2gAIAQEAAQUCdlTBVDg8qQHm7bRO0nmWfqYia6pz/8QAFhEBAQEAAAAAAAAAAAAAAAAAEBFB/9oACAEDAQE/AZpT/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8BpD//xAAfEAABAwMFAAAAAAAAAAAAAAABAAIREBJRICExQfH/2gAIAQEABj8CudK5o8npbyWYTSpHqi1oCtxo/8QAHRABAAICAgMAAAAAAAAAAAAAAQARITEQYUFRsf/aAAgBAQABPyHLg8RYy6sS4hsQQcGjrEQNzTbUyhdm4+q9U6Ebr0T8lVA5/9oADAMBAAIAAwAAABCPLIz/xAAWEQEBAQAAAAAAAAAAAAAAAAABERD/2gAIAQMBAT8QgKcpJn//xAAYEQADAQEAAAAAAAAAAAAAAAAAAREQIf/aAAgBAgEBPxB9QRKdz//EAB8QAAICAgIDAQAAAAAAAAAAAAERADEhQXGBEFFhkf/aAAgBAQABPxB+ANiCSM/HCeBsVDg7g0xGnGhgcuzE911AABSnBtvZFw5VmT2RTmsKxeAV3mGZDvMR+Aj9lPJgF6eJXvwN8z//2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"object\"\n        title=\"object\"\n        src=\"/static/b2cc3a9a4155ce83a48b9a2ebe62fb8f/066f9/object.jpg\"\n        srcset=\"/static/b2cc3a9a4155ce83a48b9a2ebe62fb8f/d2f63/object.jpg 163w,\n/static/b2cc3a9a4155ce83a48b9a2ebe62fb8f/c989d/object.jpg 325w,\n/static/b2cc3a9a4155ce83a48b9a2ebe62fb8f/066f9/object.jpg 400w\"\n        sizes=\"(max-width: 400px) 100vw, 400px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<!-- more -->\n<h2 id=\"객체-지향-프로그래밍-이야기\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EC%95%BC%EA%B8%B0\" aria-label=\"객체 지향 프로그래밍 이야기 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 프로그래밍 이야기</h2>\n<p>프로그래밍을 개인적으로 제대로 학습해 본 것은 <code>C++로 쓰여진 객체지향프로그래밍</code> 책이었다. 주황색(?)과 파란색(?)의 표지의 책으로 기억된다… 문법부터 나온 책이었는데 그때 배운 내용을 바탕으로 아직까지도 잘 써먹고(?) 있다. 누가 가르쳐 주는 것도 아니고 개발로 뭔가를 해본 것도 아니기에 난해하고 이해하기 어려워서 몇 번을 반복해서 본 기억이 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 292px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 136.80981595092027%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAIDBAUB/8QAFgEBAQEAAAAAAAAAAAAAAAAAAwIA/9oADAMBAAIQAxAAAAHO5fedmDjnPaypJtyIUv/EABwQAAEFAAMAAAAAAAAAAAAAAAEAAgMREhATMv/aAAgBAQABBQIAVlEUooo3M6ogX1pslN1al9JvH//EABoRAAMAAwEAAAAAAAAAAAAAAAABEQIDEjH/2gAIAQMBAT8B5cpTDbPUN1n/xAAaEQADAQADAAAAAAAAAAAAAAAAARECAxMh/9oACAECAQE/Ae1WeiRrgplRQ//EAB0QAAIBBAMAAAAAAAAAAAAAAAABEQIQIZEgMTL/2gAIAQEABj8CPR3JTKyyHS9mFAlvg7f/xAAdEAEBAQACAgMAAAAAAAAAAAABEQAxURBBYXGB/9oACAEBAAE/IVioOThKGFRn5srhz3nWn3dL84m0mJM68KfjPO//2gAMAwEAAgADAAAAEMsmQv/EABgRAQEBAQEAAAAAAAAAAAAAAAEAESFB/9oACAEDAQE/EPYJwwc6Rohl/8QAGBEBAQEBAQAAAAAAAAAAAAAAAQARIXH/2gAIAQIBAT8QRY68LQGLocsZO3//xAAeEAEAAwEAAQUAAAAAAAAAAAABABEhMVFBkbHB8P/aAAgBAQABPxBHpGlNu9uaUAXVI83f3mUMCrsKllSeM24j+C6UwWcnn2SwqVqPG5BNeAK+kJQornvHsbAG2aD8zep//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"book\"\n        title=\"book\"\n        src=\"/static/4f398158e752d0e6b81394703c9884e2/115fe/book.jpg\"\n        srcset=\"/static/4f398158e752d0e6b81394703c9884e2/d2f63/book.jpg 163w,\n/static/4f398158e752d0e6b81394703c9884e2/115fe/book.jpg 292w\"\n        sizes=\"(max-width: 292px) 100vw, 292px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>이게 \"상속\"이구나 이게 \"클래스\"하고 \"인터페이스\" 구나 하는 정도의 이해 수준을 가지고 나름 <code>다 배웠다는 교만함</code>으로 살았던 기억이 난다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 375px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.47852760736197%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAATABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAMEBQEC/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3q8meTqwv8D2D//EABoQAAIDAQEAAAAAAAAAAAAAAAECAAMRISL/2gAIAQEAAQUC2M3p2YM6rMBsBYSyYCSe/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAdEAABBAIDAAAAAAAAAAAAAAAAAREhcQISMkFh/9oACAEBAAY/Ajm1Dbjqkj6xR3JlQj+in//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExYXGhsf/aAAgBAQABPyFBtCW+MXH3wiHNpXcQ6mmF2ljY3LUWeElGXSCJL//aAAwDAQACAAMAAAAQgMcA/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPxAf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPxAf/8QAHxABAQADAAICAwAAAAAAAAAAAREAITFBcVFhkbHw/9oACAEBAAE/EEwQeVwGBASATrqt00zQwQTVpnhygO/TKCI3kkhH45v3rAk+O7ZfR/XGjXSk8Vb+jBcgYeBOZJXQgfgz/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"hahaha\"\n        title=\"hahaha\"\n        src=\"/static/86a884ab5c87119f3c6f62902900e3c1/bf173/hahaha.jpg\"\n        srcset=\"/static/86a884ab5c87119f3c6f62902900e3c1/d2f63/hahaha.jpg 163w,\n/static/86a884ab5c87119f3c6f62902900e3c1/c989d/hahaha.jpg 325w,\n/static/86a884ab5c87119f3c6f62902900e3c1/bf173/hahaha.jpg 375w\"\n        sizes=\"(max-width: 375px) 100vw, 375px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>그 이후로 아마도 처음보는 객체지향 프로그래밍 관련 책 같다.</p>\n<p>이 책은 시작부터 <code>프로그래밍 패러다임</code>에 대한 용어를 다룬다. 작년에 쓴 <a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=13799611\">내 책</a>에서는 다양한 패러다임(반응형/함수형 프로그래밍 패러다임)이 나오는 내용 임에도 불구하고 미처 다루지 못했던 내용을 이 책에서는 아주 잘 다루고 있다.\n(왜 이렇게 풀지 못했지… 라는 생각에 부끄러움이 밀려왔다. 하하하)</p>\n<p>이후 소프트웨어 모듈의 목적에 대해 기술하고 있다. 이걸 보고 초등학교때 '인사 잘해라'는 선생님의 가르침을 잊은 것 처럼 얼굴이 화끈거렸다.</p>\n<blockquote>\n<p>소프트웨어 모듈은</p>\n<p>첫째. 제대로 동작해야하고\n둘째. 변경을 위해 존재해야하며\n셋째. 가독성이 좋아야한다.</p>\n</blockquote>\n<h2 id=\"간혹-우리는-두번째-목적을-잊어버린다-왜\" style=\"position:relative;\"><a href=\"#%EA%B0%84%ED%98%B9-%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%91%90%EB%B2%88%EC%A7%B8-%EB%AA%A9%EC%A0%81%EC%9D%84-%EC%9E%8A%EC%96%B4%EB%B2%84%EB%A6%B0%EB%8B%A4-%EC%99%9C\" aria-label=\"간혹 우리는 두번째 목적을 잊어버린다 왜 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간혹 우리는 두번째 목적을 잊어버린다. 왜?</h2>\n<p>이 스펙이 크게 변경될 일은 현실적으로 우리가 예측가능한 범위에서 많이 일어나지 않을뿐만아니라 그런것을 고려하면서 개발하기에는 일정이 너무 짧기때문에 오히려 첫번째와 세번째 이유에 더 초점을 맞추게 된다.</p>\n<p>하긴 두번째 이유 때문에 객체지향이니 함수형이니 반응형이니 하는 프로그래밍 패러다임을 배우고, 테스트 코드를 짜놓고 변경에 대비하고 있는데… 현업 개발을 하다보면 이걸 명료하게(?) 잊어버린다.</p>\n<p>어찌보면 경험이 쌓이면서 변경을 대비하기 위한 코딩의 기술(?)들이 이미 녹아들어 갔기 때문일 수도 있다. 그냥 '그렇게 짜는게 좋다'라는 감(?)만이 남아 있게된다.</p>\n<p>이 책의 1~2장 까지는 객체지향 프로그래밍의 개념을 <code>왜?</code> 라는 관점에서 예제와 함께 비교적 쉽게 설명하고 있다. 하지만 역시나조금은 지루한 내용이고, 초보자들이 이해하기 어려운 내용이다.</p>\n<p>뭐 핵심만 이야기한다면 아래같이 간단히 나타낼 수도 있다.</p>\n<blockquote>\n<p>의존성이 있다 === 변경이 될 수 있다.</p>\n<p>So, 결합도를 낮춘다.</p>\n<p>How?</p>\n<ul>\n<li><strong>캡슐화</strong>를 통해 내,외부의 경계를 명확히하여 자율성을 보장하여 의존성을 줄인다.</li>\n<li>구현과 인터페이스로 나눠서 인터페이스로만 메시지를 주고받는다</li>\n<li>객체에 <strong>책임</strong>을 주어 할당하여 <strong>자율적</strong>으로 처리하도록 하자. 이로 인해 응집도를 높인다.</li>\n</ul>\n</blockquote>\n<p>위 기본적인 개념을 바탕으로 어떻게 코드를 개선해 나가는지를 설명하고 있다.</p>\n<h2 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h2>\n<p>위 방식을 효과적으로 해결하기 위한 객체지향 프로그래밍의 방법 중 하나로 상속이 나오고, 이로 인한 추상화와 다형성 이야기가 나온다. 이런 개념은 인터넷을 잘 찾으렴 나오니깐 과감히 생략하고. 우리가 잘못 사용(?) 하고 있는 상속에 대한 이야기를 좀 해보자.</p>\n<p>FE개발 좀 했다는 노친네(?) 분들과도 이 상속이 논의의 중심이 되었다.</p>\n<p>이 상속이라는게 어떻게 보면 참 편리하다. 부모를 그대로 쏙 닮은 자식을 아주 손쉽게 만들수 있기 때문이다.</p>\n<p>왜냐면 내 중복코드가 정말 기가 막히게 사라지기 때문이다. 유지보수도 더 편한 것 같고, 뭔가 테크닉으로 노가대를 없앴다는 프로그래머로서의 뿌듯함도 생긴다.</p>\n<h2 id=\"잘못된-상속의-폐해\" style=\"position:relative;\"><a href=\"#%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%83%81%EC%86%8D%EC%9D%98-%ED%8F%90%ED%95%B4\" aria-label=\"잘못된 상속의 폐해 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>잘못된 상속의 폐해</h2>\n<p>실제로 내가 겪은 개발 사례로 이야기해보자. UI 대표적인 컴포넌트로 캐로셀과 스크롤이 있다.</p>\n<p>둘다 사용자의 액션을 받아서 UI를 움직이는 동일한 기능을 담당한다. 다만 다른 것은 캐로셀은 별도의 인덱스가 있어서 사용자의 액션에 따라 한 판씩 이동하는 것에 비해 스크롤은 모두 동일하지만 사용자의 액션에 의해 스크롤되는 UI 컴포넌트이다.</p>\n<p>인덱스 기능을 빼면 사실 둘 다 같다. 그럼 동일한 기능이니깐 공통 사용자 액션을 바탕으로 상속해서 요렇게 하면 좋겠다라는 유혹(?)이 시작된다. 여기까지는 사실 괜찮다.</p>\n<p>관여하는 모듈도 많지도 않고 나름 나쁘지 않다. 하지만 이제 요구사항이 늘면서 우린 헬게이트로 빠지게 된다.</p>\n<p>캐로셀의 이동 모양만 변경한 여러 종류의 캐로셀을 만드는 요구사항이 추가되었다.</p>\n<p>Carousel을 상속함으로써 이동 모양에 대한 부분만 overriding 하면, SlideCarousel, PreviewCarousel, CubeCarousel 등 다양한 캐로셀을 손쉽게 만들 수 있었다. 이때는 참 뿌듯했다. 몇 줄 안되는 코드로 다양한 요구사항을 손쉽게 해결했으니 ㅋㅋㅋ</p>\n<p>하지만 문제는 여기서 부터였다. 여러 종류의 캐로셀마다 다양한 요구사항들이 추가되었고 이로 인해 하위에 있는 XXXCarousel이 변경되었고, 이로 인해 오히려 상위의 컴포넌트도 변경을 해야하는 상황이 도래했다.</p>\n<p>코드는 줄었지만. 변경시 마다 상위 모듈이 함께 변경 될 소지가 있었고 각각의 역할은 자율성을 갖지 못하고 영향을 미치게되었다. 가장 미치게 하는 것은 코드는 짧아졌지만 <code>상위 모듈을 다 이해하지 않은 이상</code> 코드의 변경이 어려워졌다.</p>\n<p>이때 했던 실수를 이 책에서는 명확하게 집혀주고 있다.</p>\n<blockquote>\n<p>상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다.</p>\n</blockquote>\n<p>이를 구현의 <code>재사용성 관점</code>으로 접근하면 나와 같은 경험을 할 수 있다. 하지만 인터페이스 상속. 즉, 다형성을 이용하기 위한 인터페이스 상속은 좋은 결과를 낳는다. 물론, <code>구현 자체를 공유할 필요가 없는 경우</code>라면 인터페이스만을 사용하는 것이 훨~씬 유연한 구조를 가져갈 수 있다.</p>\n<p>위에서 예시로 든 캐로셀과 스크롤의 경우에는 1차적으로는 사용자 액션 부분을 모듈화 하여 자율성을 부여한 후, 이를 캐로셀이나 스크롤에서 사용하는 사용자 액션을 사용하는 <code>합성</code> 방법이 더 효과적이다.</p>\n<p>다음으로 다양한 종류의 캐로셀의 경우, 캐로셀의 <u>구현체를 공유할 필요가 없다면 인터페이스</u>로 <code>추상화</code> 를 하고 그렇지 않고 <u>구현체를 일부 공유해야한다면</u> <code>상속</code>을 이용하여 <code>템플릿 메소드 패턴</code>을 고려하는 것도 좋은 방법이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.14723926380368%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt1YwqP//EABgQAAIDAAAAAAAAAAAAAAAAAAABEDJB/9oACAEBAAEFAh1yGf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgUf/aAAgBAQAGPwIi/wD/xAAbEAABBAMAAAAAAAAAAAAAAAABACExQRARYf/aAAgBAQABPyG4KuQOD76hGX//2gAMAwEAAgADAAAAECM//8QAFREBAQAAAAAAAAAAAAAAAAAAAAH/2gAIAQMBAT8QR//EABYRAAMAAAAAAAAAAAAAAAAAAAEQMf/aAAgBAgEBPxAxf//EABoQAQEAAwEBAAAAAAAAAAAAAAERACExUWH/2gAIAQEAAT8QsjRCQ+YwQR+pzJQhzglxMbeZbp3miTzP/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"templateMethod\"\n        title=\"templateMethod\"\n        src=\"/static/9336ad28df6a78b80f1b53e4f260e882/6aca1/templateMethod.jpg\"\n        srcset=\"/static/9336ad28df6a78b80f1b53e4f260e882/d2f63/templateMethod.jpg 163w,\n/static/9336ad28df6a78b80f1b53e4f260e882/c989d/templateMethod.jpg 325w,\n/static/9336ad28df6a78b80f1b53e4f260e882/6aca1/templateMethod.jpg 650w,\n/static/9336ad28df6a78b80f1b53e4f260e882/f9df6/templateMethod.jpg 691w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"인터페이스와-상속\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\" aria-label=\"인터페이스와 상속 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스와 상속</h2>\n<p>J2EE로 구현된 모듈들을 보면 많은 상속된 객체를 사용하고 있고 사용자에게는 대체로 인터페이스 구현 형태를 제시하고 있다.</p>\n<p>개발을 처음 시작할 때는 인터페이스를 보면서 이런 생각을 했었다.</p>\n<p>아니 그냥 만들면 될 것을 왜? 굳이 인터페이스를 만들어야 하는가?</p>\n<p>사실 Java개발을 할때 가장 불편하고 짜증났던 것 중에 하나가 이런 중복 코드를 매번 재생성해야하는 것이 사실 좀 불합리해 보였다. 하지만 그 대상이 여러 개라면… 즉 다형성이 필요하다면 이야기는 달라진다. 인터페이스 만한게 없다.</p>\n<blockquote>\n<p>난 이런 메시지를 줄테니 잘 모르겠고 넌 이런 형태의 응답을 줘!</p>\n</blockquote>\n<p>인터페이스 빼고는 의존성이 없다. 규칙만 잘 지키면 된다. 하지만. 상속은 어떠한가?</p>\n<p>상속은 사실 <code>굉장한 강결합</code>이다. 부모의 메소드를 알지 못하면 모르고, 부모가 어떻게 동작하는지에 대한 내용을 모르면 자식의 영향도를 파악하기가 어렵다. 한마디로 일차로 <strong>캡슐화 위반</strong>이다. 캡슐화 위반은 사실상 의존성의 증대를 의미한다.</p>\n<p>개인적인 생각으로는 극단적이지만 <code>상속은 필요 없다</code>에 한 표를 주고 싶다. 너무 매정하다 싶으면 이렇게 고치고 싶다.</p>\n<p><code>상속은 최대 한 번이면 족하다.</code></p>\n<p>상속은 결합도가 높은 패턴이기 때문에 정말 자신이 잘 만들 자신이 있거나 그렇지 않다면 오히려 당신의 퇴근시간을 늦출 수 있는 지름길이 될 수 있다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","tableOfContents":"<ul>\n<li><a href=\"/post/object-book1/#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EC%95%BC%EA%B8%B0\">객체 지향 프로그래밍 이야기</a></li>\n<li><a href=\"/post/object-book1/#%EA%B0%84%ED%98%B9-%EC%9A%B0%EB%A6%AC%EB%8A%94-%EB%91%90%EB%B2%88%EC%A7%B8-%EB%AA%A9%EC%A0%81%EC%9D%84-%EC%9E%8A%EC%96%B4%EB%B2%84%EB%A6%B0%EB%8B%A4-%EC%99%9C\">간혹 우리는 두번째 목적을 잊어버린다. 왜?</a></li>\n<li><a href=\"/post/object-book1/#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"/post/object-book1/#%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%83%81%EC%86%8D%EC%9D%98-%ED%8F%90%ED%95%B4\">잘못된 상속의 폐해</a></li>\n<li><a href=\"/post/object-book1/#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\">인터페이스와 상속</a></li>\n</ul>","frontmatter":{"title":"오브젝트 책에 대한 잡담 - 1","desc":null,"thumbnail":{"childImageSharp":{"fixed":{"src":"/static/b2cc3a9a4155ce83a48b9a2ebe62fb8f/2244e/object.jpg"}}},"date":"2019-07-31","category":"Tech","disableToc":null,"tags":["book","oop","inheritance"]}}},"pageContext":{"slug":"/post/object-book1/","previous":{"fields":{"slug":"/post/object-book2/"},"frontmatter":{"tags":["book","oop","책임주도설계","데이터중심설계","react"],"title":"오브젝트 책에 대한 잡담 - 2","category":"Tech"}},"next":{"fields":{"slug":"/post/nodejs-memoryleak/"},"frontmatter":{"tags":["nodejs","SSR","memoryleak","performance","sentry"],"title":"어서와, Memory Leak은 처음이지?","category":"Tech"}}}},"staticQueryHashes":["1990743003"]}